<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>svg-part-editor</title>
    <script src="https://cdn.tailwindcss.com/3.4.13"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.5/svg.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs@1.10.27/dist/interact.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.2/dist/svg-pan-zoom.min.js"></script>
    <style>
      :root {
        color-scheme: light;
      }
      body {
        font-family: "Avenir Next", "Avenir", "Nunito", "Segoe UI", sans-serif;
      }
      .selected-part {
        filter: drop-shadow(0 0 2px rgba(37, 99, 235, 0.9));
      }
    </style>
  </head>
  <body class="min-h-screen bg-gray-100 text-gray-900">
    <header class="border-b border-gray-200 bg-white">
      <div class="mx-auto flex max-w-5xl items-center justify-between px-6 py-5">
        <div>
          <p class="text-xs font-semibold uppercase tracking-widest text-gray-500">
            Svg Part Editor
          </p>
          <h1 class="text-2xl font-semibold tracking-tight text-gray-900">Workspace</h1>
        </div>
      </div>
    </header>
    <main class="mx-auto grid max-w-5xl gap-6 px-6 py-8">
      <section class="rounded-2xl border border-gray-200 bg-white p-6 shadow-sm">
        <div class="flex flex-col gap-3">
          <label class="text-sm font-semibold uppercase tracking-widest text-gray-500">
            SVG File
          </label>
          <input
            id="svg-file"
            type="file"
            accept=".svg"
            class="w-full cursor-pointer rounded-xl border border-dashed border-gray-300 bg-gray-50 px-4 py-3 text-sm text-gray-700 file:mr-4 file:rounded-lg file:border-0 file:bg-blue-600 file:px-4 file:py-2 file:text-xs file:font-semibold file:uppercase file:tracking-widest file:text-white hover:border-blue-400"
          />
          <p id="status" class="text-sm text-gray-500">
            Select an SVG file to read its text.
          </p>
          <div class="flex flex-wrap gap-3">
            <button
              id="serialize-btn"
              type="button"
              class="rounded-lg border border-gray-200 bg-gray-900 px-4 py-2 text-xs font-semibold uppercase tracking-widest text-white hover:bg-gray-800"
            >
              Serialize SVG
            </button>
            <button
              id="download-btn"
              type="button"
              class="rounded-lg border border-gray-200 bg-white px-4 py-2 text-xs font-semibold uppercase tracking-widest text-gray-700 hover:bg-gray-100"
            >
              Download SVG
            </button>
            <button
              id="zoom-in-btn"
              type="button"
              class="rounded-lg border border-gray-200 bg-white px-4 py-2 text-xs font-semibold uppercase tracking-widest text-gray-700 hover:bg-gray-100"
            >
              Zoom In
            </button>
            <button
              id="zoom-out-btn"
              type="button"
              class="rounded-lg border border-gray-200 bg-white px-4 py-2 text-xs font-semibold uppercase tracking-widest text-gray-700 hover:bg-gray-100"
            >
              Zoom Out
            </button>
            <button
              id="reset-btn"
              type="button"
              class="rounded-lg border border-gray-200 bg-white px-4 py-2 text-xs font-semibold uppercase tracking-widest text-gray-700 hover:bg-gray-100"
            >
              Reset View
            </button>
            <button
              id="undo-btn"
              type="button"
              class="rounded-lg border border-gray-200 bg-white px-4 py-2 text-xs font-semibold uppercase tracking-widest text-gray-700 hover:bg-gray-100"
            >
              Undo
            </button>
            <button
              id="redo-btn"
              type="button"
              class="rounded-lg border border-gray-200 bg-white px-4 py-2 text-xs font-semibold uppercase tracking-widest text-gray-700 hover:bg-gray-100"
            >
              Redo
            </button>
          </div>
        </div>
      </section>
      <section class="rounded-2xl border border-gray-200 bg-white p-6 shadow-sm">
        <div class="mb-3 text-sm font-semibold uppercase tracking-widest text-gray-500">
          Stage
        </div>
        <div
          id="stage"
          class="h-[420px] w-full rounded-xl border border-dashed border-gray-200 bg-gray-50 p-4 text-sm text-gray-500 overflow-hidden"
        >
          SVG will render here.
        </div>
      </section>
      <section class="rounded-2xl border border-gray-200 bg-white p-6 shadow-sm">
        <div class="mb-3 text-sm font-semibold uppercase tracking-widest text-gray-500">
          Properties
        </div>
        <div class="grid gap-4 sm:grid-cols-3">
          <label class="flex flex-col gap-2 text-xs font-semibold uppercase tracking-widest text-gray-500">
            Fill
            <input
              id="attr-fill"
              type="text"
              placeholder="e.g. #ff0000 or none"
              class="rounded-lg border border-gray-200 bg-gray-50 px-3 py-2 text-xs font-normal text-gray-800"
              disabled
            />
          </label>
          <label class="flex flex-col gap-2 text-xs font-semibold uppercase tracking-widest text-gray-500">
            Stroke
            <input
              id="attr-stroke"
              type="text"
              placeholder="e.g. #000000 or none"
              class="rounded-lg border border-gray-200 bg-gray-50 px-3 py-2 text-xs font-normal text-gray-800"
              disabled
            />
          </label>
          <label class="flex flex-col gap-2 text-xs font-semibold uppercase tracking-widest text-gray-500">
            Stroke Width
            <input
              id="attr-stroke-width"
              type="number"
              min="0"
              step="0.5"
              placeholder="e.g. 2"
              class="rounded-lg border border-gray-200 bg-gray-50 px-3 py-2 text-xs font-normal text-gray-800"
              disabled
            />
          </label>
        </div>
      </section>
      <section class="rounded-2xl border border-gray-200 bg-white p-6 shadow-sm">
        <div class="mb-3 text-sm font-semibold uppercase tracking-widest text-gray-500">
          Raw SVG Text
        </div>
        <textarea
          id="svg-text"
          readonly
          class="min-h-[200px] w-full resize-y rounded-xl border border-gray-200 bg-gray-50 px-4 py-3 font-mono text-xs text-gray-800 shadow-inner"
        ></textarea>
      </section>
    </main>
    <script>
      const fileInput = document.getElementById("svg-file");
      const status = document.getElementById("status");
      const output = document.getElementById("svg-text");
      const stage = document.getElementById("stage");
      const serializeButton = document.getElementById("serialize-btn");
      const downloadButton = document.getElementById("download-btn");
      const zoomInButton = document.getElementById("zoom-in-btn");
      const zoomOutButton = document.getElementById("zoom-out-btn");
      const resetButton = document.getElementById("reset-btn");
      const undoButton = document.getElementById("undo-btn");
      const redoButton = document.getElementById("redo-btn");
      const fillInput = document.getElementById("attr-fill");
      const strokeInput = document.getElementById("attr-stroke");
      const strokeWidthInput = document.getElementById("attr-stroke-width");
      let currentSvg = null;
      let selectedElement = null;
      let panZoomInstance = null;
      let interactTarget = null;
      let isRestoring = false;
      let baseViewBox = null;
      const undoStack = [];
      const redoStack = [];
      const maxHistory = 30;
      let pendingSnapshot = null;

      const ensureViewBox = (svg) => {
        const viewBox = svg.getAttribute("viewBox");
        if (viewBox) {
          svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
          baseViewBox = viewBox;
          console.info("SVG viewBox found:", viewBox);
          return;
        }

        try {
          const bbox = svg.getBBox();
          if (bbox.width && bbox.height) {
            const padX = Math.max(bbox.width * 0.05, 10);
            const padY = Math.max(bbox.height * 0.05, 10);
            const x = bbox.x - padX;
            const y = bbox.y - padY;
            const width = bbox.width + padX * 2;
            const height = bbox.height + padY * 2;
            const nextViewBox = `${x} ${y} ${width} ${height}`;
            svg.setAttribute("viewBox", nextViewBox);
            svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
            baseViewBox = nextViewBox;
            console.info("SVG viewBox generated:", nextViewBox);
          } else {
            console.info("SVG viewBox could not be computed from bbox.");
          }
        } catch (error) {
          console.warn("Failed to compute SVG viewBox.", error);
        }
      };

      fileInput.addEventListener("change", async (event) => {
        const file = event.target.files && event.target.files[0];
        if (!file) {
          status.textContent = "No file selected.";
          output.value = "";
          return;
        }

        try {
          const text = await file.text();
          window.__svgText = text;
          status.textContent = `Loaded ${file.name} (${text.length} chars).`;
          output.value = text;

          const svg = loadSvgFromString(text);
          if (svg) {
            const pathCount = svg.querySelectorAll("path").length;
            const nodeCount = svg.querySelectorAll("*").length;
            console.info("SVG file name:", file.name);
            console.info("SVG file size (bytes):", file.size);
            console.info("SVG text length (chars):", text.length);
            console.info("SVG path count:", pathCount);
            console.info("SVG element count:", nodeCount);
          }
        } catch (error) {
          status.textContent = "Failed to read file.";
          output.value = "";
          stage.textContent = "Failed to parse SVG.";
          currentSvg = null;
          console.error(error);
        }
      });

      const clearSelection = () => {
        if (selectedElement) {
          selectedElement.classList.remove("selected-part");
        }
        selectedElement = null;
        if (interactTarget) {
          interact(interactTarget).unset();
          interactTarget = null;
        }
        if (panZoomInstance) {
          panZoomInstance.enablePan();
        }
        updateAttributeInputs();
      };

      const cloneSvgForSerialization = (svg) => {
        const clone = svg.cloneNode(true);
        if (baseViewBox) {
          clone.setAttribute("viewBox", baseViewBox);
          clone.setAttribute("preserveAspectRatio", "xMidYMid meet");
        }
        const viewport = clone.querySelector(".svg-pan-zoom_viewport");
        if (viewport) {
          const children = Array.from(viewport.childNodes);
          children.forEach((child) => clone.append(child));
          viewport.remove();
        }
        return clone;
      };

      const serializeSvgElement = (svg) => {
        const serializer = new XMLSerializer();
        return serializer.serializeToString(svg);
      };

      const pushSnapshot = (reason = "update") => {
        if (!currentSvg || isRestoring) {
          return;
        }
        const serialized = serializeSvgElement(cloneSvgForSerialization(currentSvg));
        const last = undoStack[undoStack.length - 1];
        if (last === serialized) {
          return;
        }
        undoStack.push(serialized);
        if (undoStack.length > maxHistory) {
          undoStack.shift();
        }
        redoStack.length = 0;
        console.info("Snapshot saved:", reason, "stack", undoStack.length);
      };

      const scheduleSnapshot = (reason) => {
        if (pendingSnapshot) {
          clearTimeout(pendingSnapshot);
        }
        pendingSnapshot = setTimeout(() => {
          pushSnapshot(reason);
          pendingSnapshot = null;
        }, 250);
      };

      const loadSvgFromString = (text, options = {}) => {
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, "image/svg+xml");
        const svg = doc.querySelector("svg");

        stage.innerHTML = "";
        if (svg) {
          stage.append(svg);
          svg.setAttribute("width", "100%");
          svg.setAttribute("height", "100%");
          requestAnimationFrame(() => {
            ensureViewBox(svg);
            if (panZoomInstance) {
              panZoomInstance.destroy();
            }
            baseViewBox = svg.getAttribute("viewBox");
            const shouldFit = !options.viewState;
            panZoomInstance = window.svgPanZoom(svg, {
              zoomEnabled: true,
              panEnabled: true,
              controlIconsEnabled: false,
              fit: shouldFit,
              center: shouldFit,
              minZoom: 0.2,
              maxZoom: 20,
              zoomScaleSensitivity: 0.2,
            });
            if (options.viewState) {
              panZoomInstance.zoom(options.viewState.zoom);
              panZoomInstance.pan(options.viewState.pan);
            }
            console.info("svg-pan-zoom initialized.");
          });
          currentSvg = svg;
          clearSelection();
          if (!options.skipHistory) {
            pushSnapshot("load");
          }
        } else {
          stage.textContent = "No <svg> element found.";
          currentSvg = null;
          baseViewBox = null;
          clearSelection();
        }
        return svg;
      };

      const setInputsEnabled = (enabled) => {
        fillInput.disabled = !enabled;
        strokeInput.disabled = !enabled;
        strokeWidthInput.disabled = !enabled;
      };

      const updateAttributeInputs = () => {
        if (!selectedElement) {
          fillInput.value = "";
          strokeInput.value = "";
          strokeWidthInput.value = "";
          setInputsEnabled(false);
          return;
        }
        const computed = getComputedStyle(selectedElement);
        const fillValue = selectedElement.getAttribute("fill") ?? computed.fill;
        const strokeValue = selectedElement.getAttribute("stroke") ?? computed.stroke;
        const strokeWidthValue =
          selectedElement.getAttribute("stroke-width") ?? computed.strokeWidth;
        fillInput.value = fillValue || "";
        strokeInput.value = strokeValue || "";
        strokeWidthInput.value = strokeWidthValue || "";
        setInputsEnabled(true);
      };

      const applyAttribute = (name, value) => {
        if (!selectedElement) {
          return;
        }
        const trimmed = value.trim();
        if (trimmed === "") {
          selectedElement.removeAttribute(name);
        } else {
          selectedElement.setAttribute(name, trimmed);
        }
      };

      const resolveSelectablePart = (target) => {
        let cursor = target;
        while (cursor && cursor !== currentSvg) {
          if (cursor.tagName === "g") {
            if (!cursor.classList.contains("svg-pan-zoom_viewport")) {
              return cursor;
            }
          }
          cursor = cursor.parentElement;
        }
        return target;
      };

      const screenDeltaToSvgDelta = (dx, dy) => {
        if (!currentSvg) {
          return { x: dx, y: dy };
        }
        const viewport = currentSvg.querySelector(".svg-pan-zoom_viewport") || currentSvg;
        const matrix = viewport.getScreenCTM();
        if (!matrix) {
          return { x: dx, y: dy };
        }
        const inverse = matrix.inverse();
        if (typeof DOMPoint === "function") {
          const a = new DOMPoint(0, 0).matrixTransform(inverse);
          const b = new DOMPoint(dx, dy).matrixTransform(inverse);
          return { x: b.x - a.x, y: b.y - a.y };
        }
        const pointA = currentSvg.createSVGPoint();
        const pointB = currentSvg.createSVGPoint();
        pointA.x = 0;
        pointA.y = 0;
        pointB.x = dx;
        pointB.y = dy;
        const a = pointA.matrixTransform(inverse);
        const b = pointB.matrixTransform(inverse);
        return { x: b.x - a.x, y: b.y - a.y };
      };

      const attachDragHandlers = (target) => {
        if (interactTarget && interactTarget !== target) {
          interact(interactTarget).unset();
        }
        interactTarget = target;
        interact(target).draggable({
          listeners: {
            start() {
              if (panZoomInstance) {
                panZoomInstance.disablePan();
              }
              interactTarget.dataset.moved = "false";
            },
            move(event) {
              const element = SVG(event.target);
              const delta = screenDeltaToSvgDelta(event.dx, event.dy);
              element.dmove(delta.x, delta.y);
              interactTarget.dataset.moved = "true";
            },
            end() {
              if (panZoomInstance) {
                panZoomInstance.enablePan();
              }
              if (interactTarget.dataset.moved === "true") {
                pushSnapshot("move");
              }
            },
          },
        });
      };

      stage.addEventListener("click", (event) => {
        if (!currentSvg) {
          return;
        }

        const target = event.target;
        if (!(target instanceof Element)) {
          return;
        }

        if (target === stage || target === currentSvg) {
          clearSelection();
          return;
        }

        const nextSelection = resolveSelectablePart(target);
        if (selectedElement === nextSelection) {
          return;
        }

        if (selectedElement) {
          selectedElement.classList.remove("selected-part");
        }
        selectedElement = nextSelection;
        selectedElement.classList.add("selected-part");
        attachDragHandlers(selectedElement);
        updateAttributeInputs();
      });

      fillInput.addEventListener("input", (event) => {
        applyAttribute("fill", event.target.value);
        scheduleSnapshot("fill");
      });

      strokeInput.addEventListener("input", (event) => {
        applyAttribute("stroke", event.target.value);
        scheduleSnapshot("stroke");
      });

      strokeWidthInput.addEventListener("input", (event) => {
        applyAttribute("stroke-width", event.target.value);
        scheduleSnapshot("stroke-width");
      });

      const serializeCurrentSvg = () => {
        if (!currentSvg) {
          status.textContent = "No SVG loaded to serialize.";
          output.value = "";
          return null;
        }
        ensureViewBox(currentSvg);
        const serialized = serializeSvgElement(cloneSvgForSerialization(currentSvg));
        output.value = serialized;
        status.textContent = `Serialized SVG (${serialized.length} chars).`;
        console.info("SVG serialized length (chars):", serialized.length);
        return serialized;
      };

      serializeButton.addEventListener("click", () => {
        serializeCurrentSvg();
      });

      downloadButton.addEventListener("click", () => {
        const serialized = serializeCurrentSvg();
        if (!serialized) {
          return;
        }
        const blob = new Blob([serialized], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);
        const anchor = document.createElement("a");
        anchor.href = url;
        anchor.download = "edited.svg";
        document.body.append(anchor);
        anchor.click();
        anchor.remove();
        URL.revokeObjectURL(url);
        console.info("SVG download triggered.");
      });

      zoomInButton.addEventListener("click", () => {
        if (!panZoomInstance) {
          status.textContent = "No SVG loaded to zoom.";
          return;
        }
        panZoomInstance.zoomIn();
      });

      zoomOutButton.addEventListener("click", () => {
        if (!panZoomInstance) {
          status.textContent = "No SVG loaded to zoom.";
          return;
        }
        panZoomInstance.zoomOut();
      });

      resetButton.addEventListener("click", () => {
        if (!panZoomInstance) {
          status.textContent = "No SVG loaded to reset.";
          return;
        }
        panZoomInstance.resetZoom();
        panZoomInstance.center();
        panZoomInstance.fit();
      });

      const restoreSnapshot = (serialized) => {
        isRestoring = true;
        try {
          const viewState = panZoomInstance
            ? { zoom: panZoomInstance.getZoom(), pan: panZoomInstance.getPan() }
            : null;
          loadSvgFromString(serialized, { skipHistory: true, viewState });
        } finally {
          isRestoring = false;
        }
      };

      const undo = () => {
        if (undoStack.length < 2) {
          status.textContent = "Nothing to undo.";
          return;
        }
        const current = undoStack.pop();
        redoStack.push(current);
        const previous = undoStack[undoStack.length - 1];
        restoreSnapshot(previous);
      };

      const redo = () => {
        if (redoStack.length === 0) {
          status.textContent = "Nothing to redo.";
          return;
        }
        const next = redoStack.pop();
        undoStack.push(next);
        restoreSnapshot(next);
      };

      undoButton.addEventListener("click", undo);
      redoButton.addEventListener("click", redo);

      document.addEventListener("keydown", (event) => {
        const isMac = navigator.platform.toLowerCase().includes("mac");
        const modKey = isMac ? event.metaKey : event.ctrlKey;
        const key = event.key.toLowerCase();
        if (!modKey || (key !== "z" && key !== "y")) {
          return;
        }
        event.preventDefault();
        if (key === "y") {
          redo();
          return;
        }
        if (event.shiftKey) {
          redo();
        } else {
          undo();
        }
      });
    </script>
  </body>
</html>
